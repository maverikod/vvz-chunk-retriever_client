# Взаимодействие компонентов

В этом документе описывается, как компоненты пакета `chunk_metadata_adapter` взаимодействуют друг с другом и как они могут быть интегрированы в более крупные системы.

## Обзор архитектуры

Пакет разработан с использованием многоуровневой архитектуры:

```
┌─────────────────────────────────────┐
│          Клиентское приложение      │
└───────────────┬─────────────────────┘
                │
┌───────────────▼─────────────────────┐
│    ChunkMetadataBuilder (Фасад)     │
└───────────────┬─────────────────────┘
                │
┌───────────────▼─────────────────────┐
│      Уровень моделей данных         │
│  ┌───────────────┐ ┌───────────────┐ │
│  │ SemanticChunk │ │FlatSemanticCh.│ │
│  └───────┬───────┘ └───────┬───────┘ │
│          │                 │         │
│  ┌───────▼───────┐         │         │
│  │ ChunkMetrics  │         │         │
│  └───────┬───────┘         │         │
│          │                 │         │
│  ┌───────▼───────┐         │         │
│  │FeedbackMetrics│         │         │
│  └───────────────┘         │         │
└───────────────┬─────────────────────┘
                │
┌───────────────▼─────────────────────┐
│         Уровень валидации            │
└─────────────────────────────────────┘
```

## Обязанности компонентов

### ChunkMetadataBuilder

Выступает в качестве фасада для системы, предоставляя высокоуровневые методы:

- `build_flat_metadata` - Создает плоские метаданные в виде словаря
- `build_semantic_chunk` - Создает структурированные объектные метаданные
- `flat_to_semantic` - Преобразует из плоского в структурированный формат
- `semantic_to_flat` - Преобразует из структурированного в плоский формат

### Модели данных

- `SemanticChunk` - Основная структурированная модель с вложенными объектами
- `FlatSemanticChunk` - Плоское представление для хранения
- `ChunkMetrics` - Содержит метрики качества и использования:
    - quality_score, coverage, cohesion, boundary_prev, boundary_next, matches, used_in_generation, used_as_input, used_as_context, feedback
- `FeedbackMetrics` - Содержит информацию об обратной связи пользователей
- Перечисления (`ChunkType`, `ChunkRole`, `ChunkStatus`) - Определяют допустимые значения

### Уровень валидации

Встроен в модели данных и обеспечивает:

- Валидацию формата UUID (должен быть UUIDv4)
- Валидацию формата временных меток (ISO8601 с часовым поясом)
- Валидацию формата связей (шаблон relation:uuid)
- Валидацию числовых диапазонов для метрик
- Валидацию обязательных полей

## Интеграция с внешними системами

### Системы хранения

Пакет разработан для интеграции с различными системами хранения:

```
┌─────────────────┐    ┌─────────────────┐
│  Ваше RAG-прил. │    │ ChunkMetadata   │
│                 │◄───┤ Builder         │
└────────┬────────┘    └────────┬────────┘
         │                      │
         ▼                      ▼
┌─────────────────┐    ┌─────────────────┐
│ Векторная БД    │    │  Хранилище      │
│ (плоский формат)│    │ документов      │
└─────────────────┘    └─────────────────┘
```

#### Интеграция с векторной БД

```python
from chunk_metadata_adapter import ChunkMetadataBuilder
import chromadb  # Пример векторной БД

# Создаем коллекцию в векторной БД
collection = chromadb.Client().create_collection("documents")

# Генерируем метаданные для векторных представлений
builder = ChunkMetadataBuilder(project="MyProject")
metadata = builder.build_flat_metadata(
    text="Содержимое для векторизации",
    source_id=str(source_uuid),
    ordinal=1,
    type="DocBlock",
    language="russian",
    coverage=0.9
)

# Добавляем в векторную БД (плоский формат работает лучше всего)
collection.add(
    ids=[metadata["uuid"]],
    embeddings=get_embeddings(metadata["text"]),
    metadatas=[metadata]
)
```

#### Интеграция с хранилищем документов

```python
from chunk_metadata_adapter import ChunkMetadataBuilder
import json

# Создаем структурированный чанк
builder = ChunkMetadataBuilder(project="MyProject")
chunk = builder.build_semantic_chunk(
    text="Содержимое документа",
    language="russian",
    type="DocBlock",
    source_id=str(source_uuid),
    coverage=0.9
)

# Сохраняем в хранилище документов
with open(f"chunks/{chunk.uuid}.json", "w") as f:
    # При необходимости преобразуем в плоский формат
    flat_data = builder.semantic_to_flat(chunk)
    json.dump(flat_data, f)
```

### Интеграция в конвейер обработки

Пакет может быть интегрирован в конвейеры обработки:

```
┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐
│  Загрузка  │  │   Разбиение│  │ Генерация  │  │ Хранение   │
│ документа  ├─►│ на чанки   ├─►│ метаданных ├─►│ и индексация│
└────────────┘  └────────────┘  └────────────┘  └────────────┘
                                       ▲
                                       │
                               ┌───────┴───────┐
                               │ChunkMetadata  │
                               │   Builder     │
                               └───────────────┘
```

Пример конвейера:

```python
def process_document(doc_path, project_name):
    # Загружаем документ
    with open(doc_path, "r") as f:
        content = f.read()
    
    # Генерируем ID источника
    source_id = str(uuid.uuid4())
    
    # Создаем построитель метаданных
    builder = ChunkMetadataBuilder(project=project_name)
    
    # Разбиение на чанки и генерация метаданных
    chunks = []
    for i, text in enumerate(split_into_chunks(content)):
        chunk = builder.build_semantic_chunk(
            text=text,
            language="russian",
            type="DocBlock",
            source_id=source_id,
            ordinal=i,
            source_path=doc_path,
            coverage=0.9
        )
        chunks.append(chunk)
    
    # Добавляем связи между чанками
    link_chunks(chunks)
    
    # Сохраняем и индексируем чанки
    store_chunks(chunks)
    
    return chunks
```

## Производительность и масштабируемость

Пакет разработан как легковесный и масштабируемый вместе с вашим приложением:

- Низкое потребление памяти с минимальными зависимостями
- Эффективная валидация с использованием Pydantic
- Возможность использования плоского или структурированного формата в зависимости от потребностей производительности
- Потокобезопасные операции для параллельной обработки 